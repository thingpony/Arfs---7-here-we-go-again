//every quirk in this folder should be coded around being applied on spawn
//these are NOT "mob quirks" like GOTTAGOFAST, but exist as a medium to apply them and other different effects
/datum/quirk
	/// Autogenerated key that'll be used to identify the quirk in the quirk list, as well as save/load it
	var/key
	/// The name of the quirk, shown in the quirk list
	var/name = "Test Quirk"
	/// The description of the quirk, mostly flavor text
	var/desc = "This is a test quirk."
	/// The actual specific(ish) mechanics of the quirk, shown in the quirk list
	/// This is parsed by the game, so you can use $BAD, $NUT, $GOOD, and $MISC to color text
	var/mechanics = "This probably does something!"
	var/value = 0
	var/category = QUIRK_CAT_DEFAULT // misc
	/// Format: list(/datum/quirk/quirk1, /datum/quirk/quirk2, etc.)
	/// List of quirks BY TYPE that this quirk conflicts with and wont allow you to have if you have this
	var/list/conflicts = list() // can you believe at one point this was a list of strings? i know right

	var/human_only = TRUE
	var/gain_text
	var/locked = FALSE
	var/lose_text
	var/medical_record_text //This text will appear on medical records for the trait. Not yet implemented
	var/antag_removal_text // Text will be given to the quirk holder if they get an antag that has it blacklisted.
	var/mood_quirk = FALSE //if true, this quirk affects mood and is unavailable if moodlets are disabled
	var/list/mob_trait //if applicable, apply and remove these mob traits
	var/mob/living/quirk_holder
	var/datum/controller/subsystem/processing/quirks/livesfrombased // Just a dummy reference so that the GC will think this thing is being used, when really its actually totally being used
	var/reference //If this is just a reference template used by the subsystem, so it'll stop randomly dying for no raisin

/datum/quirk/New(mob/living/quirk_mob, spawn_effects, words = TRUE)
	key = "[type]" // this is the key that will be used to identify the quirk in the quirk list
	// parse_mechanics()
	for(var/q in conflicts)
		if(!ispath(q, /datum/quirk))
			stack_trace("Hey! [src] has a conflict with [q], which is not a quirk! please make sure its not a string, cus we dont do that anymore.")
	if(istype(quirk_mob, /datum/controller/subsystem/processing/quirks)) // oh shit the boss is here
		return setup_quirk_for_subsystem() // hide!
	if(!quirk_mob || (human_only && !ishuman(quirk_mob)) || quirk_mob.has_quirk(type))
		qdel(src)
		return
	quirk_holder = quirk_mob
	SSquirks.quirk_objects += src
	if(gain_text && words)
		to_chat(quirk_holder, gain_text)
	quirk_holder.mob_quirks += src
	if(mob_trait)
		if(!islist(mob_trait))
			mob_trait = list(mob_trait)
		for(var/trait in mob_trait)
			ADD_TRAIT(quirk_holder, trait, ROUNDSTART_TRAIT)
	START_PROCESSING(SSquirks, src)
	add()
	if(spawn_effects)
		on_spawn()
		addtimer(CALLBACK(src,PROC_REF(post_add)), 30)

/datum/quirk/Destroy()
	if(reference)
		return QDEL_HINT_LETMELIVE
	STOP_PROCESSING(SSquirks, src)
	remove()
	if(quirk_holder)
		quirk_holder.mob_quirks -= src
		if(mob_trait)
			if(!islist(mob_trait))
				mob_trait = list(mob_trait)
			for(var/trait in mob_trait)
				REMOVE_TRAIT(quirk_holder, trait, ROUNDSTART_TRAIT)
	SSquirks.quirk_objects -= src
	return ..()

// /datum/quirk/proc/parse_mechanics() // if only this worked
// 	var/static/regex/badtoken = regex(@"$BAD\(([^\w!?,.=%#&+\/\-]*?)\)", "g")
// 	mechanics = badtoken.Replace_char(mechanics, "[span_alert("$1")]")
// 	var/static/regex/nuttoken = regex(@"$NUT\(([^\w!?,.=%#&+\/\-]*?)\)", "g")
// 	mechanics = nuttoken.Replace_char(mechanics, "[span_notice("$1")]")
// 	var/static/regex/goodtoken = regex(@"$GOOD\(([^\w!?,.=%#&+\/\-]*?)\)", "g")
// 	mechanics = nuttoken.Replace_char(mechanics, "[span_notice("$1")]")
// 	var/static/regex/misctoken = regex(@"$MISC\(([^\w!?,.=%#&+\/\-]*?)\)", "g")
// 	mechanics = misctoken.Replace_char(mechanics, "[span_monkeylead("$1")]")
// 	mechanics = span_suppradio(mechanics)

/datum/quirk/proc/preremove(words)
	if(!words)
		return
	if(lose_text)
		to_chat(quirk_holder, lose_text)

/datum/quirk/proc/get_conflicts()
	var/returnlist = list() // so now we're gonna convert the list of paths to string names, like it was before, but better cus I did it
	for(var/quirk in conflicts)
		returnlist += "[quirk]"
	return returnlist

/datum/quirk/proc/setup_quirk_for_subsystem()
	reference = TRUE // this is just a reference template, so it doesnt do anything
	livesfrombased = SSquirks.hi() // dont ask
	return // mainly so it doesnt process or do anything wierd, its just gonna chill in the subsystem and be a var template

/datum/quirk/proc/transfer_mob(mob/living/to_mob)
	quirk_holder.mob_quirks -= src
	to_mob.mob_quirks += src
	if(mob_trait)
		if(!islist(mob_trait))
			mob_trait = list(mob_trait)
		for(var/trait in mob_trait)
			REMOVE_TRAIT(quirk_holder, trait, ROUNDSTART_TRAIT)
			ADD_TRAIT(to_mob, trait, ROUNDSTART_TRAIT)
	quirk_holder = to_mob
	on_transfer()

/datum/quirk/proc/add() //special "on add" effects
/datum/quirk/proc/on_spawn() //these should only trigger when the character is being created for the first time, i.e. roundstart/latejoin
/datum/quirk/proc/remove() //special "on remove" effects
/datum/quirk/proc/on_process() //process() has some special checks, so this is the actual process
/datum/quirk/proc/post_add() //for text, disclaimers etc. given after you spawn in with the trait
/datum/quirk/proc/on_transfer() //code called when the trait is transferred to a new mob

/datum/quirk/proc/clone_data() //return additional data that should be remembered by cloning
/datum/quirk/proc/on_clone(data) //create the quirk from clone data
/datum/quirk/proc/removed_cus_antag(mob/living/to_mob)
	to_chat(to_mob, antag_removal_text || span_boldannounce("You're atnagonistic overwrights you [src]!"))

/datum/quirk/process()
	if(QDELETED(quirk_holder))
		quirk_holder = null
		qdel(src)
		return
	if(quirk_holder.stat == DEAD)
		return
	on_process()

/mob/living/proc/get_trait_string(medical) //helper string. gets a string of all the traits the mob has
	var/list/dat = list()
	if(!medical)
		for(var/V in mob_quirks)
			var/datum/quirk/T = V
			dat += T.name
		if(!dat.len)
			return "None"
		return dat.Join(", ")
	else
		for(var/V in mob_quirks)
			var/datum/quirk/T = V
			dat += T.medical_record_text
		if(!dat.len)
			return "None"
		return dat.Join("<br>")

/mob/living/proc/cleanse_trait_datums() //removes all trait datums
	for(var/V in mob_quirks)
		var/datum/quirk/T = V
		qdel(T)

/mob/living/proc/transfer_trait_datums(mob/living/to_mob)
	for(var/V in mob_quirks)
		var/datum/quirk/T = V
		T.transfer_mob(to_mob)

/*

Commented version of Nearsighted to help you add your own traits
Use this as a guideline

/datum/quirk/nearsighted
	name = "Nearsighted"
	///The trait's name

	desc = "You are nearsighted without prescription glasses, but spawn with a pair."
	///Short description, shows next to name in the trait panel

	value = -1
	///If this is above 0, it's a positive trait; if it's not, it's a negative one; if it's 0, it's a neutral

	mob_trait = TRAIT_NEARSIGHT
	///This define is in __DEFINES/traits.dm and is the actual "trait" that the game tracks
	///You'll need to use "HAS_TRAIT_FROM(src, X, sources)" checks around the code to check this; for instance, the Ageusia trait is checked in taste code
	///If you need help finding where to put it, the declaration finder on GitHub is the best way to locate it

	gain_text = span_danger("Things far away from you start looking blurry.")
	lose_text = span_notice("You start seeing faraway things normally again.")
	medical_record_text = "Subject has permanent nearsightedness."
	///These three are self-explanatory

/datum/quirk/nearsighted/on_spawn()
	var/mob/living/carbon/human/H = quirk_holder
	var/obj/item/clothing/glasses/regular/glasses = new(get_turf(H))
	H.put_in_hands(glasses)
	H.equip_to_slot(glasses, SLOT_GLASSES)
	H.regenerate_icons()

//This whole proc is called automatically
//It spawns a set of prescription glasses on the user, then attempts to put it into their hands, then attempts to make them equip it.
//This means that if they fail to equip it, they glasses spawn in their hands, and if they fail to be put into the hands, they spawn on the ground
//Hooray for fallbacks!
//If you don't need any special effects like spawning glasses, then you don't need an add()

*/
